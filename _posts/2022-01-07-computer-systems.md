---
layout: post
title:  "Computer Systems"
date:   2022-01-07 23:12:12 +0100
categories: hardware assembly operating-systems computer-science 
---

Watching Carnegie Mellon lectures for Introduction to Computer Systems, focused on the chapters on Machine-Level programming to understand the low level details better.

---

### Lecture 05 Machine-Level Programming
`objdump` -d can disassemble a binary to see what assembly instructions it executes.

`(%rcx)` specifies that a register holds a memory address to be dereferenced. It feels so good to understand it after all this time of looking at gdb outputs.

`(%rdx, %rcx, 4)` - scales rcx by 4 (multiplies)

`0x80 (, %rdx,2)` - scales rdx by 2 then adds an offset of 0x80  

`leaq` - load effective address instruction. Can be used like Cs `&` where it computes an address, but C compiler likes to use it for computing arithmetic expressions of the form x + k * y.
So far I understand that it takes some of the displacement and scale arguments to compute the arithmethic result by bit shifting and then stores it in a register. Ends up being faster than the multiplication operation.
`q` at the end of the command just means quad, for the word size `quadword`
### Lecture 06 Control
x86-64 has 16 registers. %rsp is the only special now at the moment, the stack pointer. Turns out %rip is special too, it isn't accessed in a normal way and it just tells processor which instruction is beign executed.
Condition codes 
* CF - Carry Flag (for unsigned)
* ZF - Zero Flag
* SF - Sign Flag (if negative, for signed)
* OF - Overflow Flag (for signed) (how do we know there was an overflow in addition? the signs of two operands are the same and result has opposite sign)

Windows and Linux use different conventions for their x86 instructions, dest and src are swapped.

`compq src2, src1` - compare instruction works by subtracting one src from another and then setting the condition codes, depending on the condition code we know how the two numbers relate.

`testq src2, src1` - sets the condition codes based on the value of src1 & src2, in practice can use the same value for both operands when we want to use only one.

In x86 any computation which ends up in a 32 bit value assigned to a 64bit register the rest of the 32 bits will be padded with zeros. 16 bit (2 bytes) instructions only manipulate the specified bytes.

> Modern CPU is like an oil tanker in the sea, it makes it's way and it's really hard for it to turn or change direction.

About conditionals and branching being disruptive to the instruction flow in pipelines.

Compiler can infer that it's good optimization to precompute both branches of a conditional so that the execution runs smoothly, just like Fedor suggested in his talk on writing effective CPP. GCC will only do that if both branches are straighforward.

Loops are decomposed into conditional jumps, which seem to be pretty straighforward without optimization flags.
I like the optimization in which compiler recognizes that the initial condition has to be true so it won't bother checking it in the beginning but moves it to the end. I thought we would hear more about loop unrolling at this point, if we have two constants in the condition then that would be a perfect target for that?

Fallthrough in C switch statement is one of the worst decisions in the history of design of the programming language :D
It's been a cause of many bugs and doesn't make much sense to the lecturer.

`ja` - jump above instruction, jumps to the instruction if the value is above provided value. There is a smart trick here that it will both jump if it's higher signed or unsigned value or if it's a negative value, because signed values appear as bigger unsigned ones.

The compiler can replace a switch statement with if-else if there's sparsely populated switch with big value differences. That is because the missing values for the default case will get filled in so that the range of other cases is catered for.

Jump tables are generated by the compiler to implement the switch statements which have a constant time complexity, they don't have to examine any other statements than the one constant refers to.

Does it mean that there is no branch predictions with switches? Are they better for the performance?